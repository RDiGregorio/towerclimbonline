import 'dart:async';
import 'dart:io';
import 'dart:math';

import 'package:logging/logging.dart';
import 'package:mailer/mailer.dart';
import 'package:mailer/smtp_server/gmail.dart';
import 'package:quiver/async.dart';
import 'package:towerclimbonline/config.dart';
import 'package:towerclimbonline/content.dart';
import 'package:towerclimbonline/server.dart';
import 'package:towerclimbonline/util.dart';

// *****************************************************************************
// fixme: captcha wasn't working in Russia
// fixme: find a way to prevent account creation spam
// fixme: chat timestamps don't convert from time to date until refresh
// TODO: use the tick clock for all delays (including death/summoning delays)
// *****************************************************************************
// TODO: second action bar row
//**********************************************************************
// FIXME: can move while shopping, breaking interface
//**********************************************************************
// FIXME: some player image layers have the wrong dimensions
// FIXME: update.sh sometimes doesn't work (possible race condition?)
// FIXME: can lose connection to the database (cloud platform availability?)
// TODO: shoreline logic (is this needed? walls would still be jagged...)
// FIXME: trading with someone with a modal open is buggy
// TODO: proc gen shops
// TODO: eventually remove all usages of the "small" function
// TODO: add a "guard" mode for pets
// FIXME: charming a human changes the human's looks
// FIXME: standing on a rat (or any doll with a margin) causes buggy shadows
//**********************************************************************
// TODO: handle database errors better
//**********************************************************************
// FIXME: somehow a player got an item with an amount of 0
// he max updated a stack he bought from the exchange
// FIXME: autocomplete on login prevent login
// FIXME: you can stair dance to heal while bossing with multiple accounts
// FIXME BIG HP: problems caused by using big ints for hp
//**********************************************************************
// TODO: possible god that disables berserk/burst (snail god?)
// TODO: best pet would have burst berserk electric poison attack and life

void main() {
  Logger.root
    ..onRecord.listen((LogRecord record) async =>
        output('[${record.time}] ${record.message}'));

  runZoned(_main, onError: (error, trace) {
    Logger.root.severe(error);
    Logger.root.severe(trace);
  });
}

Future<dynamic> _main() async {
  Logger.root.info('starting server');

  // Makes sure the port is available.

  await runZoned(
      () => ServerSocket.bind(InternetAddress.anyIPv6, Config.port)
          .then((server) => server.close()),
      onError: (error, trace) => exit(0));

  // Renews certificates.

  if (Platform.isLinux) {
    renew() => Process.run('./renew.sh', const [], runInShell: true);

    var renewResult = await renew();
    Logger.root.info('renew certificate exit code: ${renewResult.exitCode}');

    if (renewResult.stderr.isNotEmpty)
      Logger.root.info(renewResult.stderr.trim());

    Timer.periodic(const Duration(days: 1), (timer) => renew());
  } else {
    Logger.root.info('unable to run shell script');
  }

  // Handles serialization.

  registerFactory(#Account, () => Account());
  registerFactory(#Scores, () => Scores());
  registerFactory(#Exchange, () => Exchange());
  registerFactory(#ExchangeOffer, () => ExchangeOffer());
  registerFactory(#ObservableEvent, () => ObservableEvent());
  registerFactory(#Session, () => Session());
  registerFactory(#Doll, () => Doll());
  registerFactory(#DollInfo, () => DollInfo());
  registerFactory(#Item, () => Item());
  registerFactory(#ItemContainer, () => ItemContainer());
  registerFactory(#CharacterSheet, () => CharacterSheet());
  registerFactory(#Stat, () => Stat());
  registerFactory(#DollCustomization, () => DollCustomization());
  registerFactory(#CustomizationLayer, () => CustomizationLayer());
  registerFactory(#Buff, () => Buff());

  Future(() async {
    var secretConfig = await secret,
        playerSpawnStageName = 'dungeon0',
        playerSpawnLocation = const Point(36, 163);

    ServerGlobals.playerSpawnStage = Stage(playerSpawnStageName, 100, 100);

    // Stages and terrain sections must have unique names.
    // [playerSpawnStage] is filled with content later in the code.

    var stages = {playerSpawnStageName: ServerGlobals.playerSpawnStage},
        locks = {};

    // Allows procedural generation in a session.

    Future<dynamic> _proceduralStage(
        ResourceManager stageManager, int floor, Future<dynamic> future) async {
      var stageKey = 'procgen$floor';

      // Prevents the same floor from being generated by multiple players at the
      // same time.

      if (locks[stageKey] == true) await until(() => locks[stageKey] != true);
      var fullKey = stageKey + '_0_0', file = File('dat/$fullKey.json');

      // Tries to load the stage as a resource.

      Stage<Doll> stage =
          await stageManager.getResource(() => null, stageKey, future);

      // If that fails, tries to load the stage from the disk.

      try {
        if (stage == null && await file.exists()) {
          stage = Stage(stageKey, 100, 100);

          stage.setCollisionMap(fullKey,
              await newCollisionMap(stage, fullKey, const Point(0, 0)));

          stageManager.replace(stageKey, stage);
          locks.remove(stageKey);
          return stage;
        }
      } catch (error) {
        stage = null;
        Logger.root.severe('failed to load floor $floor');
      }

      if (stage != null) {
        locks.remove(stageKey);
        return stage;
      }

      // Otherwise, regenerates the floor and saves it to the disk.

      Logger.root.info('generating floor $floor');
      await ProceduralGenerator().generate(floor);

      // Loads the floor from the disk.

      stage = Stage(stageKey, 100, 100);

      stage.setCollisionMap(
          fullKey,
          await newCollisionMap(stage, fullKey, const Point(0, 0)),
          const Point(0, 0));

      stageManager.replace(stageKey, stage);

      var result =
          await stageManager.getResource(() => stage, stageKey, future);

      locks.remove(stageKey);
      return result;
    }

    Session.proceduralStage = _proceduralStage;

    var data = List.from(Directory('dat')
        .listSync()
        .map((file) => file.uri.pathSegments[1].split('.')[0])
        .where((name) =>
            !name.startsWith('procgen') && !name.startsWith('placeholder'))
        .map((name) {
      assert('_'.allMatches(name).length == 2);
      dynamic parts = List<dynamic>.from(name.split('_'));
      parts[1] = int.parse(parts[1]);
      parts[2] = int.parse(parts[2]);
      return parts;
    }));

    for (var i = 0; i < data.length; i++) {
      var key = data[i][0];
      stages[key] ??= Stage(key, 100, 100);
    }

    // Registers abilities.

    registerAbilities(stages);

    // Registers items.

    registerItems(stages);

    // Enables crafting.

    Crafting.init();

    // Registers dolls.

    registerDolls(stages);

    for (var i = 0; i < data.length; i++) {
      var stage = stages[data[i][0]],
          key = data[i].join('_'),
          offset = Point<int>(data[i][1] * 100, data[i][2] * 100);

      stage!.setCollisionMap(
          key, await newCollisionMap(stage, key, offset), offset);
    }

    var accountManager = await newPostgresResourceManager('accounts'),
        channelManager = await newPostgresResourceManager('channels'),

        // Stages aren't saved.

        stageManager = newMockResourceManager(stages),
        exchangeManager = await newPostgresResourceManager('exchange'),
        scoreManager = await newPostgresResourceManager('scores'),
        directMessageManager = await newPostgresResourceManager('dm');

    // Periodically updates scores.

    Timer.periodic(
        Duration(seconds: 1),
        (timer) => accountManager.resources.forEach((key, account) {
              if (account.sessions.isNotEmpty)
                account.sessions.first.updateScores(key);
            }));

    // Handles errors.

    onError(error, trace) {
      Logger.root.severe(error);
      Logger.root.severe(trace);
    }

    host(
        Config.port,
        (socket) => Session(() {
              var account = Account(
                  Doll()..currentLocation = playerSpawnLocation,
                  DollInfo(thisCanPass: Terrain.doll),
                  playerSpawnStageName,
                  playerSpawnLocation);

              var weapon = Item('revolver');

              account
                ..lootItem(weapon)
                ..doll.equip(weapon);

              account.lootItem(Item('leash'));

              if (false && Config.debug) {
                account.sheet.stats.forEach((stat) {
                  stat.ascensions = 29;
                  stat.experience = stat.experienceFromLevel(Stat.maxLevel);
                });

                account.equipped.clear();
                var upgrades = 150000;

                [
                  Item.fromDisplayText('+$upgrades burst demon energy wrath'),
                  Item.fromDisplayText('+$upgrades burst demon energy wrath'),
                  Item.fromDisplayText('+$upgrades defense life amulet'),
                  Item.fromDisplayText('+$upgrades spirit power boots'),
                  Item.fromDisplayText('+$upgrades spirit power gloves'),
                  Item.fromDisplayText('+$upgrades spirit meteorite crown'),
                  Item.fromDisplayText('+$upgrades spirit super resist ring'),
                  Item.fromDisplayText('+$upgrades spirit distortion robe'),
                  Item.fromDisplayText('+$upgrades spirit distortion cloak')
                ].forEach((item) {
                  account.lootItem(item);
                  account.doll.equip(item);
                });

                account.sheet
                  ..healthBuffs = upgrades
                  ..dexterityBuffs = upgrades
                  ..agilityBuffs = upgrades
                  ..strengthBuffs = upgrades
                  ..intelligenceBuffs = upgrades;

                account
                  ..lootItem(Item('+$upgrades pizza', 1000))
                  ..lootItem(Item('fast potion', 1000))
                  ..lootItem(Item('strength potion', 1000))
                  ..lootItem(Item('dexterity potion', 1000))
                  ..lootItem(Item('agility potion', 1000))
                  ..lootItem(
                      Item.fromDisplayText('+$upgrades crystal pickaxe'));

                // Elyvilon is not found in the temple.

                account.god = 'elyvilon';
              }

              return account;
            }, accountManager, channelManager, stageManager, exchangeManager,
                scoreManager, directMessageManager, socket.done),
        onError: onError);

    kill() async {
      ServerGlobals.shuttingDown = true;
      await httpServer?.close(force: true);
      await httpsServer?.close(force: true);
      ServerGlobals.sockets.forEach((socket) => socket.close());

      accountManager.resources
        ..values.expand((value) => value.sessions).forEach(kick);

      var attempts = 0;

      function() {
        // Waits for everything to save before restarting.

        var accounts = accountManager.resources.length,
            channels = channelManager.resources.length,
            exchange = exchangeManager.resources.length,
            scores = scoreManager.resources.length,
            messages = directMessageManager.resources.length;

        if (attempts < 10 &&
            (accounts > 0 ||
                channels > 0 ||
                exchange > 0 ||
                scores > 0 ||
                messages > 0)) {
          attempts += 1;
          Future.delayed(const Duration(seconds: 1), function);
        } else {
          Logger.root.info('stopping server');
          Future.delayed(const Duration(seconds: 1), () => exit(0));
        }
      }

      function();
    }

    Session.secret.addAll(secretConfig);

    // Allows sending emails.

    Session.sendEmail = (String email, String text) => send(
        Message()
          ..from = 'towerclimbonline@gmail.com'
          ..recipients.add(email)
          ..subject = 'recovery code'
          ..text = text,
        gmail(secretConfig['email'], secretConfig['email password']));

    Clock.start(Duration(milliseconds: ServerGlobals.tickDelay));

    Clock.ticks.expand((time) {
      var result = [];

      result.addAll(nearbyDolls(
          accountManager.resources.values.map((account) => account.doll),
          ServerGlobals.sight * 2,
          ServerGlobals.sight * 2));

      // Shuffles the result to make dolls act in a random order.

      return result..shuffle();
    })
      ..listen((doll) => runZoned(() => doll.upkeep(), onError: onError))
      ..listen((doll) => runZoned(() => doll.act(), onError: onError))
      ..listen((doll) => runZoned(() => doll.applyEffects(), onError: onError));

    // Tracks memory.

    /*
    if (Platform.isLinux)
      Timer.periodic(Duration(minutes: 1), (timer) async {
        var memory = await availableMemory;
        Logger.root.info('memory: $memory');
      });
    */

    // Registers a command that saves everything before exiting.

    Session.adminCommands['kill'] = (Session session, String password) async {
      if (password != (await secret)['admin password']) return;

      var restartDelay = Config.debug
              ? const Duration(seconds: 1)
              : const Duration(minutes: 5),
          restartTime = DateTime.now().add(restartDelay).millisecondsSinceEpoch;

      // Warns about the server restarting.

      Metronome.periodic(const Duration(seconds: 1)).listen((time) => session
          .peerAccounts
          .forEach((id, account) => account.sessions.forEach((peerSession) =>
              peerSession.internal['restart time'] ??= restartTime)));

      Future.delayed(restartDelay, kill);
    };
  });
}
